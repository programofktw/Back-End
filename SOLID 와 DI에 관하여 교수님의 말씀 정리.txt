	SOLID 와 DI에 관하여 교수님의 말씀 정리

1. SOLID 개발 원칙은 각각이 상호 연관적인 요소가 존재하지만
이를 구분하여 인지하고 있는 것이 중요 포인트이다.

2. OCP와 DIP는 확연하게 구분이 못할 것 같은 상황이다. 혹시 다른 시야가 있다면 말해달라.


이하는 교수님의 말씀을 제가 받아들인 내용으로 서술하겠습니다.

3. SRP : 단일 책임 원칙
	- 클래스 하나에는 한가지 기능만이 존재해야한다는 원칙
	- 해당 원칙을 따르지 않았다면 특정 기능에 문제가 생겼을 경우,
		해당 기능을 고치기 위해서 프로그램 소스 코드 곳곳에 존재하는 에러코드를 찾아야하며
		이는 실질적인 실무의 영역에서는 불가능한 부분임.
	- 그럼으로 특정 기능을 하는 것은 반드시 한 개의 클래스에 존재하고 해당 클래스의 기능을 사용하는
		다른 클래스에선 해당 클래스로부터 기능을 제공 받아야하지 각자가 개발해서는 안됨.

	- 이때 클래스로부터 기능을 제공받을 때는 DIP 원칙에 따라서 구현된 클래스가 아닌 해당 클래스의
		기능을 설계한 인터페이스를 의존하도록 해야함.
	
4. OCP : 개방 폐쇄의 원칙
	- 소프트웨어의 구성요소는 확장은 가능하지만 변경은 불가하다는 원칙
	- 여기서 확장이란 특정 기능을 수행하는 클래스가 인터페이스나 추상클래스 혹은 클래스를 상속 받는
		일이 있을 때, 부모에서 설계된 기능들을 자신에게 맞게 구현하는 것.
	- 변경이란 위와 같은 상황에서 부모에서 설계된 기능 외의 추가적인 기능 추가, 본래 기능 용도의 			
		변경이 일어나는 경우를 의미한다고 생각(제자 K의 의견)
	- 위의 의미에서의 확장은 가능하고 변경은 불가능하다는 것을 준수하는 원칙.
	- 해당 기능과 관련있는것이 생성자 주입 방식인데 이는 더 공부가 필요할 것이라고 생각함.


	다른 원칙과의 상관 관계
		- 해당 OCP 원칙의 경우에는 부모의 기능에서 벗어나면 안된다는 점은 
			SRP에도 영향을 미쳐 클래스에는 한가지 기능만 존재해야한다는 것으로 이어짐.
		- 기반 타입에서 벗어나지 않고 확장하여 서브 타입을 구현하였기 떄문에
			서브 타입을 언제든 기반 타입으로 교체할 수 있어야한다는 LSP를 충족하게 됨.

	이번 스프링 스터디에서는
	MemoryMemeberRepository, JpaMemberRepository과 SpringDataJpaRepository가 개방 폐쇄 원칙으로
	MemberRepository 인터페이스의 설계를 확장하여 구현하고 별도의 기능이 추가되지 않았음.
	

5. LSP : 리스코프 치환의 원칙
	- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 원칙
	- 선언은 기반 타입, 생성은 서브 타입으로 대입하는 방법을 사용
	- 해당 기능을 통해서 자바의 다형성을 이용한 개발이 되는 것.
	
	이번 스프링 스터디에서는
	MemberRepository로 참조 변수 memberRepository를 선언하고
	Repository의 구현 방식(MemoryMemeberRepository, JpaMemberRepository, SpringDataJpaRepository)에 따라
	생성하는 방법으로 MemberRepository의 다형성을 가능케 하였다.

	

6. ISP : 인터페이스 분리의 원칙
	- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙.
	- 이는 인터페이스 분야의 SRP라고 생각이 듦.
	- 다른 클래스에 종속될 때는 가능한 최소한의 인터페이스를 사용해야하기 때문에
		인터페이스를 설계할 때 필요한 기능만을 담아 설계해야함.
	
	이번 스터링 스터디에서는
	MemberRepository 인터페이스는 Member 데이터와 관련된 기능만을 포함하고 있었으며
	해당 인터페이스를 종속 받은 서브 타입들은 인터페이스의 기능을 모두 사용하며
	인터페이스 분리의 원칙을 만족하였음.

7. DIP : 의존성 역전의 원칙
	- 클래스 간에 직접적인 의존관계를 끊고 간접적으로 의존관계를 형성하게 만들어
		의존관계 속 클래스가 서로의 변경으로부터 자유롭게 한다
		=> 해당 내용을 교수님은 '인터페이스는 껍데기다'으로 함축적이게 표현
	- 해당 내용은 DBMS에서의 데이터 독립성과도 유사한 개념으로써 받아들여진다.

8. DI : 의존 관계 주입
	- 의존 관계란 의존 대상이 변하면 그것이 다른 클래스에 영향을 미치는 관계를 의미한다.
	- DI의 경우에는 라이브러리와 프레임워크의 차이점에서 해당 사실을 인지할 수 있다.
		라이브러리는 개발의 주체가 프로그래머로 의존관계의 주입을 프로그래머가 담당하지만
		스프링 프레임워크의 경우에는 의존관계 주입을 스프링의 DI 컨테이너가 담당하게 된다.
	- 위와같은 내용은 IOC의 일부이며, IOC는 제어반전이라는 의미로
		스프링 프레임워크(컨테이너)가 컴포넌트의 설정, 의존관계 설정, 생명주기를 담당한다는 의미이다.
	- DI에는 수정자 주입, 생성자 주입, 필드 주입이 존재하며 실무에서는 OCP를 충족하기위해
		생성자 주입을 써야함.
	-  DI를 주입하는 방법에는 @Bean 에너테이션과 @Component에너테이션이 있다.

해당 과제를 통한 느낀점
	- SOLID라는 것을 통해 객체지향이라는 것을 체감할 수 있었으며, 내가 여태까지 짠 코드가 얼마나
	부족했는지를 알 수 있었고, 스프링 스터디에서의 예제 코드를 좀더 깊은 시각으로 이해할 수 있었음.

	- 또한 DI 컨테이너의 존재를 알게 됨으로써 프레임워크가 가진 개발 주체성을 알고 
		Bean과 component에 대한 이해를 조금은 더 할 수 있었던 것 같습니다.

	- 마지막으로 위의 원칙을 지키기 위해서는 도메인에대한 높은 이해도가 바탕이 되어야만 가능할 것같다는
		것을 알 수 있었고 여기서 저번 교수님과 교수님 멘토분의 대화 중에 교수님의 
		핀테크 도메인 지식을 높게 평가하고 중요하다 하신 말씀을 이해할 수 있었습니다.  

SOLID 개발 원칙에대한 내 생각
	-위에 개념적인 내용은 제외하고 SOLID에대한 생각을 서술해보자면
	S O L I D 각각 유사한 개념을 포함하고 있고 그것을 보는 시각에서 차이가 있다는 교수님의 생각에
	동의하며
	
	(상위 모듈 : 사용자 입장 / 하위 모듈 : 서비스 제공자 입장)
	S / I는 유사하지만 구현체(S)와 인터페이스(I)에서의 시선에서 단일책임을 주장하는 것이고
	L은 OCP가 성립했을 때 적용될 수 있는 실무적 원칙
	O와 D도 유사하지만 O는 새로운 상위 모듈을 만들때 주의해야할 점이고
	D는 초기 설계시의 유의사항이지 않을까 생각하였습니다. 물론 정확히 이 상황에서만 해당 원칙을 지켜야한다는 것은 아니고 만약 구분한다면 저만의 구분 기준으로써 제시해본 것입니다.

	
	